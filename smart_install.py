#!/usr/bin/env python3
"""
Smart installer for YouTube Terminal Search
Handles shell detection, venv awareness, and multiple installation modes
"""

import os
import sys
import shutil
import subprocess
import platform
from pathlib import Path

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

class YTSearchInstaller:
    def __init__(self):
        self.home = Path.home()
        self.current_dir = Path.cwd()
        self.shell_type = self.detect_shell()
        self.rc_file = self.get_rc_file()
        
    def detect_shell(self):
        """Detect the current shell"""
        # Check environment variables first
        if 'ZSH_VERSION' in os.environ or 'ZSH_NAME' in os.environ:
            return 'zsh'
        elif 'BASH_VERSION' in os.environ:
            return 'bash'
        elif 'FISH_VERSION' in os.environ:
            return 'fish'
        
        # Check SHELL environment variable
        shell_env = os.environ.get('SHELL', '')
        if 'zsh' in shell_env:
            return 'zsh'
        elif 'bash' in shell_env:
            return 'bash'
        elif 'fish' in shell_env:
            return 'fish'
        
        # Platform-specific defaults
        if platform.system() == 'Darwin':  # macOS
            return 'zsh'  # macOS default since Catalina
        else:
            return 'bash'  # Linux default
    
    def get_rc_file(self):
        """Get the appropriate RC file for the shell"""
        rc_files = {
            'zsh': self.home / '.zshrc',
            'bash': self.home / ('.bash_profile' if platform.system() == 'Darwin' else '.bashrc'),
            'fish': self.home / '.config' / 'fish' / 'config.fish'
        }
        return rc_files.get(self.shell_type, self.home / '.bashrc')
    
    def check_venv(self):
        """Check if we're in a virtual environment"""
        if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
            print(f"{Colors.YELLOW}‚ö†Ô∏è  Warning: You're currently in a virtual environment:{Colors.NC}")
            print(f"{Colors.YELLOW}   {sys.prefix}{Colors.NC}")
            print(f"{Colors.YELLOW}   The installation will use your system Python.{Colors.NC}")
            print()
            response = input("Do you want to continue? (y/n): ").lower()
            if response != 'y':
                print(f"{Colors.RED}Installation cancelled.{Colors.NC}")
                sys.exit(1)
            return True
        return False
    
    def show_menu(self):
        """Show installation menu"""
        print(f"{Colors.BLUE}{'‚ïê' * 60}{Colors.NC}")
        print(f"{Colors.GREEN}     YouTube Terminal Search - Smart Installer{Colors.NC}")
        print(f"{Colors.BLUE}{'‚ïê' * 60}{Colors.NC}")
        print()
        
        # Check for venv
        in_venv = self.check_venv()
        
        # Show detected environment
        print(f"{Colors.BLUE}üîç Detected shell:{Colors.NC} {self.shell_type}")
        print(f"{Colors.BLUE}üìù Configuration file:{Colors.NC} {self.rc_file}")
        print(f"{Colors.BLUE}üêç Python:{Colors.NC} {sys.executable}")
        if in_venv:
            print(f"{Colors.YELLOW}üîß Mode: Virtual Environment Active{Colors.NC}")
        print()
        
        print(f"{Colors.GREEN}Installation Options:{Colors.NC}")
        print("1) Development mode (use current directory)")
        print("2) User installation (~/.local/share/yt-search)")
        print("3) Symlink to ~/.local/bin")
        print("4) Portable mode (create standalone script)")
        print()
        
        choice = input("Choose installation method (1-4): ").strip()
        return choice
    
    def create_wrapper_script(self, install_dir, target_path):
        """Create a wrapper script that works with any Python"""
        wrapper_content = f'''#!/bin/sh
# YouTube Terminal Search wrapper script
# Auto-generated by installer

# Try to use python3, fall back to python
if command -v python3 >/dev/null 2>&1; then
    exec python3 "{install_dir}/youtube_search.py" "$@"
elif command -v python >/dev/null 2>&1; then
    exec python "{install_dir}/youtube_search.py" "$@"
else
    echo "Error: Python not found. Please install Python 3."
    exit 1
fi
'''
        target_path.write_text(wrapper_content)
        target_path.chmod(0o755)
    
    def install_development(self):
        """Development mode - just create alias"""
        print(f"{Colors.BLUE}üì¶ Installing in development mode...{Colors.NC}")
        
        alias_cmd = f"alias yt-search='python3 {self.current_dir}/youtube_search.py'"
        self.add_alias(alias_cmd)
        
        return self.current_dir
    
    def install_user(self):
        """Install to user directory"""
        print(f"{Colors.BLUE}üì¶ Installing to ~/.local/share...{Colors.NC}")
        
        install_dir = self.home / '.local' / 'share' / 'yt-search'
        install_dir.mkdir(parents=True, exist_ok=True)
        
        # Copy files
        shutil.copy2('youtube_search.py', install_dir)
        if (self.current_dir / 'src').exists():
            shutil.copytree('src', install_dir / 'src', dirs_exist_ok=True)
        
        # Create wrapper in ~/.local/bin
        bin_dir = self.home / '.local' / 'bin'
        bin_dir.mkdir(parents=True, exist_ok=True)
        wrapper_path = bin_dir / 'yt-search'
        
        self.create_wrapper_script(install_dir, wrapper_path)
        
        # Add ~/.local/bin to PATH if needed
        self.ensure_path(bin_dir)
        
        return install_dir
    
    def install_symlink(self):
        """Create symlink only"""
        print(f"{Colors.BLUE}üîó Creating symlink...{Colors.NC}")
        
        bin_dir = self.home / '.local' / 'bin'
        bin_dir.mkdir(parents=True, exist_ok=True)
        
        target = bin_dir / 'yt-search'
        source = self.current_dir / 'youtube_search.py'
        
        # Remove existing symlink if it exists
        if target.exists() or target.is_symlink():
            target.unlink()
        
        target.symlink_to(source)
        source.chmod(0o755)
        
        # Add ~/.local/bin to PATH if needed
        self.ensure_path(bin_dir)
        
        return self.current_dir
    
    def install_portable(self):
        """Create a single portable script"""
        print(f"{Colors.BLUE}üì¶ Creating portable script...{Colors.NC}")
        
        # This would bundle everything into a single file
        # For now, just create a wrapper
        bin_dir = self.home / '.local' / 'bin'
        bin_dir.mkdir(parents=True, exist_ok=True)
        
        wrapper_path = bin_dir / 'yt-search'
        self.create_wrapper_script(self.current_dir, wrapper_path)
        
        self.ensure_path(bin_dir)
        
        return self.current_dir
    
    def add_alias(self, alias_cmd):
        """Add alias to shell RC file"""
        if not self.rc_file.exists():
            self.rc_file.touch()
        
        rc_content = self.rc_file.read_text()
        
        # Check if alias already exists
        if 'alias yt-search=' in rc_content:
            print(f"{Colors.YELLOW}‚ö†Ô∏è  Alias already exists in {self.rc_file}{Colors.NC}")
            response = input("Update it? (y/n): ").lower()
            if response == 'y':
                # Remove old alias
                lines = rc_content.split('\n')
                lines = [l for l in lines if not l.startswith('alias yt-search=')]
                rc_content = '\n'.join(lines)
                self.rc_file.write_text(rc_content + f'\n{alias_cmd}\n')
                print(f"{Colors.GREEN}‚úÖ Alias updated!{Colors.NC}")
        else:
            self.rc_file.write_text(rc_content + f'\n{alias_cmd}\n')
            print(f"{Colors.GREEN}‚úÖ Alias added to {self.rc_file}{Colors.NC}")
    
    def ensure_path(self, bin_dir):
        """Ensure bin directory is in PATH"""
        path_export = f'export PATH="$HOME/.local/bin:$PATH"'
        
        if self.rc_file.exists():
            rc_content = self.rc_file.read_text()
            if '.local/bin' not in rc_content:
                print(f"{Colors.YELLOW}Adding ~/.local/bin to PATH...{Colors.NC}")
                self.rc_file.write_text(rc_content + f'\n{path_export}\n')
    
    def run(self):
        """Run the installer"""
        choice = self.show_menu()
        
        install_methods = {
            '1': self.install_development,
            '2': self.install_user,
            '3': self.install_symlink,
            '4': self.install_portable
        }
        
        if choice not in install_methods:
            print(f"{Colors.RED}Invalid option. Exiting.{Colors.NC}")
            sys.exit(1)
        
        install_dir = install_methods[choice]()
        
        # Show completion message
        print()
        print(f"{Colors.GREEN}{'‚ïê' * 60}{Colors.NC}")
        print(f"{Colors.GREEN}‚úÖ Installation complete!{Colors.NC}")
        print(f"{Colors.GREEN}{'‚ïê' * 60}{Colors.NC}")
        print()
        print(f"{Colors.BLUE}To start using yt-search:{Colors.NC}")
        print()
        print(f"  source {self.rc_file}")
        print(f"  yt-search")
        print()
        print(f"{Colors.YELLOW}Or start a new terminal session.{Colors.NC}")
        print()
        
        # Uninstall instructions
        print(f"{Colors.BLUE}To uninstall:{Colors.NC}")
        if choice == '1':
            print(f"  Remove alias from {self.rc_file}")
        elif choice == '2':
            print(f"  rm -rf {install_dir}")
            print(f"  rm ~/.local/bin/yt-search")
        elif choice == '3':
            print(f"  rm ~/.local/bin/yt-search")
        elif choice == '4':
            print(f"  rm ~/.local/bin/yt-search")

if __name__ == '__main__':
    installer = YTSearchInstaller()
    installer.run()
